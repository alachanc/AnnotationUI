var React = require('react');
var SockJS = require('sockjs-client');
var stompjs = require('@stomp/stompjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var SockJS__default = /*#__PURE__*/_interopDefaultLegacy(SockJS);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var StompContext = React.createContext(undefined);

var _excluded = ["url", "children", "stompClientOptions"];
/**
 * The StompSessionProvider manages the STOMP connection
 * All Hooks and HOCs in this library require an ancestor of this type.
 * The URL to connect to can be specified via the url prop.
 * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.
 * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs
 * Custom @stomp/stompjs options can be used as props.
 * Please consult the @stomp/stompjs documentation for more information.
 */

function StompSessionProvider(props) {
  var url = props.url,
      children = props.children,
      stompClientOptions = props.stompClientOptions,
      stompOptions = _objectWithoutPropertiesLoose(props, _excluded); // Support old API


  if (stompClientOptions) stompOptions = stompClientOptions;

  var _useState = React.useState(undefined),
      client = _useState[0],
      setClient = _useState[1];

  var subscriptionRequests = React.useRef(new Map());
  React.useEffect(function () {
    var _client = new stompjs.Client(stompOptions);

    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {
      _client.webSocketFactory = function () {
        var _window, _window$location;

        var parsedUrl = new URL(url, (_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.href);

        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {
          return new SockJS__default["default"](url);
        } else if (parsedUrl.protocol === 'ws:' || parsedUrl.protocol === 'wss:') {
          return new WebSocket(url);
        } else throw new Error('Protocol not supported');
      };
    }

    _client.onConnect = function (frame) {
      if (stompOptions.onConnect) stompOptions.onConnect(frame);
      subscriptionRequests.current.forEach(function (value) {
        value.subscription = _client.subscribe(value.destination, value.callback, value.headers);
      });
      setClient(_client);
    };

    _client.onWebSocketClose = function (event) {
      if (stompOptions.onWebSocketClose) stompOptions.onWebSocketClose(event);
      setClient(undefined);
    };

    if (!stompOptions.onStompError) {
      _client.onStompError = function (frame) {
        throw frame;
      };
    }

    _client.activate();

    return function () {
      _client.deactivate();
    };
  }, [url].concat(Object.values(stompOptions)));

  var subscribe = function subscribe(destination, callback, headers) {
    if (headers === void 0) {
      headers = {};
    }

    var subscriptionId = Math.random().toString(36).substr(2, 9);
    var subscriptionRequest = {
      destination: destination,
      callback: callback,
      headers: headers
    };
    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);

    if (client && client.connected) {
      subscriptionRequest.subscription = client.subscribe(destination, callback, headers);
    }

    return function () {
      var subscriptionData = subscriptionRequests.current.get(subscriptionId);

      if (subscriptionData.subscription) {
        subscriptionData.subscription.unsubscribe();
      }

      subscriptionRequests.current["delete"](subscriptionId);
    };
  };

  return React__default["default"].createElement(StompContext.Provider, {
    value: {
      client: client,
      subscribe: subscribe
    }
  }, children);
}

/**
 *
 * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.
 * @param onMessage Callback called when a message arrives for this subscription
 * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.
 */

function useSubscription(destinations, onMessage, headers) {
  if (headers === void 0) {
    headers = {};
  }

  var stompContext = React.useContext(StompContext);
  if (stompContext === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');
  var callbackRef = React.useRef(onMessage);

  var _destinations = Array.isArray(destinations) ? destinations : [destinations];

  callbackRef.current = onMessage;
  React.useEffect(function () {
    var cleanUpFunctions = [];

    _destinations.forEach(function (_destination) {
      return cleanUpFunctions.push(stompContext.subscribe(_destination, function (message) {
        callbackRef.current(message);
      }, headers));
    });

    return function () {
      cleanUpFunctions.forEach(function (_cleanUpFunction) {
        _cleanUpFunction();
      });
    };
  }, [Object.values(_destinations).toString(), Object.values(headers).toString()]);
}

/**
 * Returns the Stomp Client from @stomp/stompjs
 * This will be undefined if the client is currently not connected
 */

function useStompClient() {
  var context = React.useContext(StompContext);
  if (context === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');
  return context.client;
}

function withStompClient(WrappedComponent) {
  return function (props) {
    var stompClient = useStompClient();
    return React__default["default"].createElement(WrappedComponent, Object.assign({
      stompClient: stompClient
    }, props));
  };
}

function withSubscription(WrappedComponent, destinations, headers) {
  if (headers === void 0) {
    headers = {};
  }

  return function (props) {
    var ref = React.useRef();
    useSubscription(destinations, function (message) {
      if (ref.current) ref.current.onMessage(message);
    }, headers); // @ts-ignore

    return React__default["default"].createElement(WrappedComponent, Object.assign({
      ref: ref
    }, props));
  };
}

var subscriptions = new Map();
function subscribeMock(destination, callback, // @ts-ignore
// eslint-disable-next-line @typescript-eslint/no-unused-vars
headers) {

  var subscriptionId = Math.random().toString(36).substr(2, 9);

  if (!subscriptions.has(destination)) {
    subscriptions.set(destination, new Map());
  } // @ts-ignore


  subscriptions.get(destination).set(subscriptionId, callback);
  return function () {
    // @ts-ignore
    subscriptions.get(destination)["delete"](subscriptionId);
  };
}
/**
 * Simulates receiving a message from the server to the specified destination
 * @param destination The topic to send the message to
 * @param message The message to send
 */

function mockReceiveMessage(destination, message) {
  if (subscriptions.has(destination)) {
    // @ts-ignore
    subscriptions.get(destination).forEach(function (callback) {
      callback(message);
    });
  }
}
/**
 * Gets the current subscriptions for the specified destination
 * @param destination The topic to get the subscriptions for, or undefined to get all subscriptions
 */

function getMockSubscriptions(destination) {
  if (destination) {
    return subscriptions.get(destination);
  }

  return subscriptions;
}

var messages = new Map();
/**
 * A mock implementation of the publish function of the @stomp/stompjs client.
 * Will store the messages in a map, keyed by the destination.
 * @param params
 */

function mockClientPublish(params) {
  if (!messages.has(params.destination)) {
    messages.set(params.destination, []);
  } // @ts-ignore


  messages.get(params.destination).push(params);
}
/**
 * Gets a default Mock of the @stomp/stompjs client.
 * If you require a custom client, you can use this as a base.
 */

function getMockClient() {
  return {
    publish: mockClientPublish
  };
}
/**
 * Gets all messages which have been sent via a mock client.
 * @param destination The destination to get messages for, or undefined to get all messages.
 */

function getSentMockMessages(destination) {
  if (destination) {
    return messages.get(destination);
  }

  return messages;
}

/**
 * A mock StompSessionProvider.
 * Messages send via this mock implementation can be received via the getSentMockMessages method.
 * Subscriptions can be received via the getMockSubscriptions method.
 * The sendMockMessage method can be used, to simulate receiving a message from the server.
 *
 * @param props.client Optional. Can be used to provide a custom mock of the sompjs client,
 * in case you require additional properties/functions to be present. getMockClient can be used as a base.
 * @constructor
 */

function StompSessionProviderMock(props) {
  var _props$client;

  return React__default["default"].createElement(StompContext.Provider, {
    value: {
      subscribe: subscribeMock,
      // @ts-ignore
      client: (_props$client = props.client) != null ? _props$client : getMockClient()
    }
  }, props.children);
}

/**
 * Resets the state of the mock implementation, clearing all subscriptions and messages.
 */

function reset() {
  subscriptions.clear();
  messages.clear();
}

var index = {
  __proto__: null,
  StompSessionProviderMock: StompSessionProviderMock,
  getMockClient: getMockClient,
  mockClientPublish: mockClientPublish,
  mockReceiveMessage: mockReceiveMessage,
  getSentMockMessages: getSentMockMessages,
  reset: reset,
  getMockSubscriptions: getMockSubscriptions
};

exports.StompSessionProvider = StompSessionProvider;
exports.mock = index;
exports.useStompClient = useStompClient;
exports.useSubscription = useSubscription;
exports.withStompClient = withStompClient;
exports.withSubscription = withSubscription;
//# sourceMappingURL=index.js.map
